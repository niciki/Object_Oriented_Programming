\documentclass[12pt]{article}

\usepackage{fullpage}
\usepackage{multicol,multirow}
\usepackage{tabularx}
\usepackage{ulem}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage{minted}

\usepackage{color} %% это для отображения цвета в коде
\usepackage{listings} %% собственно, это и есть пакет listings

\lstset{ %
language=C++,                 % выбор языка для подсветки (здесь это С++)
basicstyle=\small\sffamily, % размер и начертание шрифта для подсветки кода
numbers=left,               % где поставить нумерацию строк (слева\справа)
%numberstyle=\tiny,           % размер шрифта для номеров строк
stepnumber=1,                   % размер шага между двумя номерами строк
numbersep=5pt,                % как далеко отстоят номера строк от подсвечиваемого кода
backgroundcolor=\color{white}, % цвет фона подсветки - используем \usepackage{color}
showspaces=false,            % показывать или нет пробелы специальными отступами
showstringspaces=false,      % показывать или нет пробелы в строках
showtabs=false,             % показывать или нет табуляцию в строках
frame=single,              % рисовать рамку вокруг кода
tabsize=2,                 % размер табуляции по умолчанию равен 2 пробелам
captionpos=t,              % позиция заголовка вверху [t] или внизу [b] 
breaklines=true,           % автоматически переносить строки (да\нет)
breakatwhitespace=false, % переносить строки только если есть пробел
escapeinside={\%*}{*)}   % если нужно добавить комментарии в коде
}


\begin{document}
\begin{titlepage}
\begin{center}
\textbf{МИНИСТЕРСТВО ОБРАЗОВАНИЯ И НАУКИ РОССИЙСКОЙ ФЕДЕРАЦИИ
\medskip
МОСКОВСКИЙ АВИАЦИОННЫЙ ИНСТИТУТ
(НАЦИОНАЛЬНЫЙ ИССЛЕДОВАТЕЛЬСКИЙ УНИВЕРСТИТЕТ)
\vfill\vfill
{\Huge ЛАБОРАТОРНАЯ РАБОТА №8} \\
по курсу объектно-ориентированное программирование
I семестр, 2021/22 уч. год}
\end{center}
\vfill

Студент \uline{\it {Пономарев Никита Владимирович, группа М8О-207Б-20}\hfill}

Преподаватель \uline{\it {Дорохов Евгений Павлович}\hfill}

\vfill
\end{titlepage}

\subsection*{Условие}
 - Вариант 19:\\
Используя структуру данных, разработанную для лабораторной работы №5, спроектировать и 
разработать аллокатор памяти для динамической структуры данных.
Цель построения аллокатора – минимизация вызова операции malloc. Аллокатор должен 
выделять большие блоки памяти для хранения фигур и при создании новых фигур-объектов 
выделять место под объекты в этой памяти.
Алокатор должен хранить списки использованных/свободных блоков. Для хранения списка 
свободных блоков нужно применять динамическую структуру данных (контейнер 2-го уровня, 
согласно варианту задания).
Для вызова аллокатора должны быть переопределены оператор new и delete у классов-фигур.

Исходный код лежит в 11 файлах:
\begin{enumerate}
\item main.cpp: основная программа, взаимодействие с пользователем посредством команд из меню
\item figure.h:    описание абстрактного класса фигур
\item point.h:     описание класса точки
\item TNaryTree\_item.h:  описание класса элемента н-дерева
\item TNaryTree.h: описание класса н-дерева
\item rectangle.cpp: описание класса прямоугольника, наследующегося от figures
\item point.cpp:     реализация класса точки
\item rectangle.cpp: реализация класса прямоугольника, наследующегося от figures
\item TNaryTree.cpp:  реализация класса н-дерева
\item TNaryTree\_item.cpp:  реализация класса элемента н-дерева
\item Iterator.h:  реализация класса итератора н-дерева
\item TAllocatorBlock.h:  реализация класса алокатора н-дерева
\item TVector.h:  реализация класса шаблонного вектора для использования в аллокаторе
\item TVector\_item.h:  реализация класса элемента шаблонного вектора для использования в аллокаторе

\end{enumerate}
\pagebreak
\subsection*{Дневник отладки}
Проблем и ошибок при написании данной работы не возникло.

\subsection*{Недочёты}


\subsection*{Выводы}
В процессе выполнения работы я на практике познакомился с понятием аллокатора. Так как во многих структурах данных используются аллокаторы, то это очень важная тема, которую должен знать каждый программист на С++. Написание собственноручного итератора помогает реализовать собственную логику выделения памяти, которая может быть более оправданной в некоторых ситуациях, чем стандартный аллокатор, как для самописных, так и для стандартных структур данных.


\vfill
\pagebreak
\subsection*{Исходный код:}

{\Huge figure.h}
\inputminted
    {C++}{figure.h}
    
{\Huge point.h}
\inputminted
    {C++}{point.h}
    
{\Huge point.cpp}
\inputminted
    {C++}{point.cpp}

{\Huge rectangle.h}
\inputminted
    {C++}{rectangle.h}
    
{\Huge rectangle.cpp}
\inputminted
    {C++}{rectangle.cpp}

{\Huge TNaryTree\_item.h}
\inputminted
    {C++}{TNaryTree_item.h}
    
{\Huge TNaryTree\_item.cpp}
\inputminted
    {C++}{TNaryTree_item.cpp}

{\Huge TNaryTree.h}
\inputminted
    {C++}{TNaryTree.h}
    
{\Huge TNaryTree.cpp}
\inputminted
    {C++}{TNaryTree.cpp}

{\Huge Iterator.h}
\inputminted
    {C++}{Iterator.h}

{\Huge TVector.h}
\inputminted
    {C++}{TVector.h}
    
{\Huge TVector\_item.h}
\inputminted
    {C++}{TVector_item.h}
    
{\Huge TAllocatorBlock.h}
\inputminted
    {C++}{TAllocatorBlock.h}

{\Huge main.cpp}
\inputminted
    {C++}{main.cpp}
    
\end{document}
